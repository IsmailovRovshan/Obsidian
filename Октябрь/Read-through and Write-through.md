# Ключевая идея (в одну фразу)

- **Read-through**: при промахе в кэше сам кэш (или слой-обёртка) отвечает за чтение из источника данных и заполнение кэша. Клиент обращается только к кэшу.
    
- **Write-through**: при записи клиент пишет в кэш, а кэш **синхронно** записывает в источник (БД). Клиент получает подтверждение записи после того, как оба слоя — кэш и БД — согласованы.
    

# Участники

- Клиент (application code — сервис/контроллер)
    
- Кэш (поставщик кэша, обычно память или Redis, возможно с обёрткой/провайдером)
    
- Источник правды (primary store) — БД, API и т.д.
    

# Read-through — пошагово (чтение)

1. Клиент делает запрос: `Get(key)` → обращается к кэшу (через провайдер/обёртку).
    
2. Кэш проверяет: есть ли `key` (hit)?  
    2.1. Если **hit**: кэш возвращает значение клиенту. Конец.  
    2.2. Если **miss**: кэш сам выполняет чтение из источника правды: `value = LoadFromStore(key)` (например, SELECT в БД).
    
3. Кэш получает `value` от источника.
    
4. Кэш помещает `value` в себя (с TTL/политикой) и возвращает `value` клиенту.
    
5. Клиент получает данные, ничего не знает о БД напрямую.
    

# Write-through — пошагово (запись)

1. Клиент выполняет `Put(key, value)` (или `Update/Set/Delete`) через кэш-провайдер.
    
2. Кэш принимает запись и **синхронно** пишет в источник правды: `StoreToSource(key, value)` (например, SQL UPDATE/INSERT).
    
3. После успешной записи в источник кэш сохраняет значение локально (или подтверждает, что оно уже в кэше).
    
4. Кэш возвращает подтверждение клиенту (успех или ошибка).