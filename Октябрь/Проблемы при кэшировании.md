
---

## 1. **Несогласованность данных (Cache Inconsistency)**

**Что это:**  
Данные в кэше устарели и не соответствуют данным в БД.

**Пример:**  
Вы обновили товар в БД, но забыли обновить или удалить запись в кэше.  
Пользователь видит старую цену.

**Решения:**
- Инвалидация кэша при изменении данных (delete/update cache).
- Использовать `write-through` или `write-behind`, чтобы кэш и БД были синхронизированы.
- TTL (время жизни) для автоматического удаления устаревших данных.

---

## 2. **Cache Stampede (Штурм кэша)**

**Что это:**  
Когда кэш очищается (истекает TTL) и множество запросов одновременно обращаются к БД для восстановления кэша.

**Пример:**  
Популярный ключ истёк → 1000 запросов одновременно идут в БД → база не выдерживает.

**Решения:**

- Лок или mutex при заполнении кэша (например, `SemaphoreSlim` или Redis lock).
- Добавлять **jitter** (случайное смещение TTL), чтобы ключи не истекали одновременно.
- Применять паттерн **refresh-ahead** — обновлять кэш заранее в фоне.
- Использовать «double-checked caching»: второй запрос ждёт первый.

---

## 3. **Cache Avalanche (Кэш-лавина)**

**Что это:**  
Массовое истечение TTL у множества ключей одновременно → лавина запросов к БД.

**Отличие от Stampede:**  
Stampede — много запросов к одному ключу, Avalanche — к множеству ключей сразу.

**Решения:**
- Случайные TTL (± 10–20%) для распределения времени истечения.
- Постепенное обновление ключей в фоне.
- Использование `refresh-ahead`.

---

## 4. **Cache Penetration (Пробой кэша)**

**Что это:**  
Запросы приходят к **несуществующим ключам**, которых никогда не было в кэше → каждый раз обращение к БД.

**Пример:**  
Кто-то постоянно запрашивает `user_id = -1` или `9999999`, которых нет в базе.

**Решения:**

- **Negative caching** — кэшировать результат «не найдено» (например, на 1 минуту).
    
- Фильтрация запросов на уровне приложения.
    
- **Bloom filter** — хранить вероятностный список допустимых ключей в памяти.
    

---

## 5. **Cache Pollution (Загрязнение кэша)**

**Что это:**  
Кэш наполняется редко используемыми данными, вытесняя действительно нужные.

**Решения:**

- Настроить политику вытеснения (LRU, LFU).
    
- Не кэшировать редко используемые или большие объекты.
    
- Делить кэш по категориям/приоритетам.
    

---

## 6. **Cache Warm-up (Холодный старт)**

**Что это:**  
После перезапуска кэша (например, Redis упал) — он пуст, и первые запросы сильно нагружают БД.

**Решения:**

- **Предварительное наполнение (pre-warming)** — подгрузить ключевые данные при старте.
    
- Постепенное наполнение при первых обращениях (lazy loading).
    
- Репликация/персистентность в Redis (RDB, AOF) — чтобы не терять состояние.
    

---

## 7. **Гонки при обновлении (Race Conditions)**

**Что это:**  
Два потока одновременно обновляют один ключ → один из них перезаписывает новое значение старым.

**Решения:**

- Distributed lock (например, Redis RedLock).
    
- Версионирование (ключи с версиями: `user:1:v2`).
    
- Compare-and-set (CAS) операции.
    

---

## 8. **Переполнение кэша / Out of Memory**

**Что это:**  
Кэш растёт бесконтрольно, превышая лимиты памяти (особенно MemoryCache).

**Решения:**

- Задавать размерные лимиты (`SizeLimit`, eviction policy).
    
- Использовать Redis с eviction policy (`maxmemory-policy`).
    
- Мониторить hit/miss ratio.
    

---

## 9. **Избыточное кэширование**

**Что это:**  
Кэш добавляют без необходимости, увеличивая сложность и потребление памяти.

**Пример:**  
Кэширование данных, которые легко и быстро вычисляются (например, короткие справочники).

**Решения:**

- Измеряйте выгоду: latency, hit/miss ratio.
    
- Кэшировать только то, что реально дорого получать.
    

---

## 10. **Безопасность и консистентность**

**Что это:**  
Данные в кэше могут содержать чувствительную информацию (например, токены), или разные инстансы приложения держат разные версии данных.

**Решения:**

- Использовать распределённый кэш (Redis, Memcached) для согласованности.
    
- Шифровать чувствительные данные в кэше.
    
- Настроить TTL, чтобы токены не жили слишком долго.
    

---

Если хочешь, я могу составить **таблицу "проблема → пример → решение"** (удобную как шпаргалку для собеседования или документации).  
Сделать в Markdown или в виде кода C# с комментариями — как тебе удобнее?