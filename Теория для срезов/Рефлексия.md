**Рефлексия (Reflection)** — это механизм в .NET, который позволяет получать **метаданные** о типах (классах, структурах, интерфейсах и т.д.) во время выполнения программы (at runtime). Проще говоря, это способность кода анализировать ("интроспектировать") сам себя, а также другие сборки и типы, и динамически взаимодействовать с ними.

[[Рефлексия код]]
### Что конкретно можно делать с помощью рефлексии?
1. **Получать информацию о типе:** Узнать его имя, пространство имен, базовый класс, реализуемые интерфейсы.
2. **Исследовать члены типа:** Получить список всех методов, свойств, полей, событий и конструкторов.
3. **Динамически создавать экземпляры объектов** даже если тип неизвестен на этапе компиляции.
4. **Динамически вызывать методы** и **получать или устанавливать значения свойств и полей**.
5. **Создавать новые типы "на лету"** (с помощью `System.Reflection.Emit`), что используется, например, компиляторами или ORM.
---
### Практический пример
Допустим, у нас есть простой класс:
```csharp
public class Person
{
    public string Name { get; set; }
    private int _age;

    public Person() { }
    public Person(string name) { Name = name; }

    public void Greet()
    {
        Console.WriteLine($"Hello, my name is {Name}");
    }

    private void SecretMethod()
    {
        Console.WriteLine("This is a secret!");
    }
}
```
Теперь посмотрим, как рефлексия позволяет работать с этим классом, не зная о его устройстве на этапе компиляции.

#### 1. Получение типа (метаданных)

Первый шаг — получить объект типа `System.Type`. Это отправная точка для всей рефлексии.

```csharp
// Самый распространенный способ - с помощью typeof()
Type personType = typeof(Person);

// Альтернативный способ - если есть экземпляр объекта
Person personInstance = new Person();
Type personType2 = personInstance.GetType();

// Или если известно имя типа как строка (очень мощный прием!)
Type personType3 = Type.GetType("YourNamespace.Person");
```

### Плюсы рефлексии

- **Гибкость и динамизм:** Позволяет создавать очень гибкие приложения, которые могут работать с типами, о которых ничего не знали при компиляции (например, плагины).
    
- **Основа для мощных инструментов:** Без рефлексии были бы невозможны:
    - **ORM (Entity Framework, Dapper):** Они dynamically создают SQL-запросы, мапят результаты запросов на свойства ваших классов.
    - **Сериализаторы (JSON, XML):** Анализируют структуру объекта, чтобы правильно его преобразовать.
    - **Инверсия управления / Dependency Injection:** Фреймворки (как [ASP.NET](https://asp.net/) Core) ищут подходящие конструкторы и сервисы для их внедрения.
    - **Инструменты анализа кода и модульное тестирование:** Тестовые runner-ы используют рефлексию для поиска всех методов с атрибутом `[Test]`.
        

### Минусы и предостережения

1. **Производительность:** Операции рефлексии значительно **медленнее** прямого вызова кода. Кэширование полученных `MethodInfo`, `PropertyInfo` и т.д. является обязательной практикой для повышения производительности.
2. **Сложность:** Код с рефлексией сложнее читать, отладывать и поддерживать.
3. **Проблемы безопасности:** Рефлексия обходит модификаторы доступа (можно вызвать `private` метод). Для этого требуются соответствующие разрешения (в .NET Framework полное доверие). В современных версиях .NET (Core+) security model строже.