Отлично — кратко и по делу: перечислю основные способы коммуникации между микросервисами, кратко о плюсах/минусах и когда применять. Примеры — для тех, кто на C#.

# Основные способы

1. **HTTP / REST (JSON)**
    - Синхронно, простая реализация, широко совместима.
    - Минусы: задержки, зависимость от доступности внешнего сервиса.
    - Когда: простые CRUD/HTTP API, внешние интеграции.
    - Пример (C#):

        ```csharp
        var client = httpClientFactory.CreateClient("UserService");
        var user = await client.GetFromJsonAsync<UserDto>($"api/user/{id}");
        ```
        
2. **gRPC (HTTP/2, Protobuf)**
    - Синхронно или асинхронно, эффективная бинарная сериализация, контракт через .proto.
    - Низкая задержка, сильная типизация.
    - Минусы: сложнее для браузеров, требует генерации клиентских классов.
    - Когда: сервисы внутри кластера, высокопроизводительные вызовы.
    - Пример: генерируем клиент из .proto и вызываем `await client.GetUserAsync(new GetUserRequest{Id=id});`
        
3. **Message broker / очереди (асинхронно)** — RabbitMQ, Apache Kafka, Azure Service Bus и т.д.
    
    - Асинхронная коммуникация, развязывает сервисы во времени, обеспечивает устойчивость и ретраи.
    - Минусы: сложнее инфраструктура, eventual consistency.
    - Когда: интеграция, обработка фоновых задач, события домена, масштабирование.
    - Пример (MassTransit + RabbitMQ):
        ```csharp
        services.AddMassTransit(x =>
        {
            x.UsingRabbitMq((ctx, cfg) => cfg.Host("rabbitmq://localhost"));
        });
        // Publish
        await bus.Publish(new OrderCreated { OrderId = 1, UserId = 2 });
        ```
        
4. **Event stream / лог событий (Kafka, Pulsar)**
    
    - Подходит для событийных архитектур, аналитики, replay, CQRS/event sourcing.
    - Высокая пропускная способность, упор на потоковую обработку.
    - Минусы: операционная сложность, задержка согласованности.
    - Когда: события домена, аудита, аналитика.
5. **GraphQL**
    - Клиент запрашивает ровно нужные поля; удобно для агрегации данных из нескольких сервисов.
    - Минусы: сложнее кэширование, возможна избыточная нагрузка на сервисы.
    - Когда: когда клиенту нужно гибко формировать запросы (например, фронтенд).
        
6. **WebSocket / Server-Sent Events (SSE)**
    
    - Двусторонняя связь (WebSocket) или однонаправленная потоковая рассылка (SSE).
    - Когда: real-time (чаты, обновления статусов, уведомления).
        
7. **gRPC-Web / HTTP streaming**
    
    - Для сценариев стриминга данных через HTTP/2, в браузере — gRPC-Web.
        
    - Когда нужен поток данных с низкой латентностью.
        
8. **Shared database / shared storage (антипаттерн)**
    
    - Сервисы напрямую читают/пишут в одну БД — быстро, но сильно связывает сервисы и ломает инкапсуляцию.
        
    - Лучше избегать, использовать только в ограниченных, контролируемых случаях.
        
9. **Redis (pub/sub, shared cache)**
    
    - Быстро для pub/sub уведомлений и кэша.
        
    - Минусы: pub/sub в Redis не долговечен (если подписчика нет — сообщение потеряно).
        
10. **Actor systems (Akka.NET, Orleans)**
    
    - Абстракция акторов для масштабируемых распределённых приложений.
        
    - Когда: сложная распределённая логика, требующая состояния и подсистемы акторов.
        
11. **Change Data Capture (CDC)**
    
    - Читаем изменения из БД (Debezium) и транслируем события в поток (Kafka).
        
    - Когда: интеграция с устаревшими системами или необходимость синхронизации данных.
        

# Как выбирать

- Нужна синхронность и простота → **REST** или **gRPC**.
    
- Нужна высокая пропускная способность/потоки → **Kafka**.
    
- Хочется асинхронности и надёжности с retry/queue → **RabbitMQ / Service Bus**.
    
- Real-time → **WebSocket / SSE**.
    
- Фронтенду удобнее — гибкие запросы → **GraphQL**.
    
- Избегай shared DB как замены API.
    

Если хочешь — могу:

- показать пример gRPC-сервиса и клиента на C#;
    
- или показать пример публикации/подписки через MassTransit + RabbitMQ;
    
- либо помочь подобрать схему коммуникации для конкретного сценария (например: оплата, уведомления, отчёты).